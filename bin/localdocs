#!/usr/bin/env python3
"""
LocalDocs - Simple documentation downloader optimized for LLM workflows
"""

import json
import os
import sys
import hashlib
import urllib.request
import urllib.error
import re
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
import argparse

# Constants
MIN_TERMINAL_WIDTH = 60
DEFAULT_TERMINAL_WIDTH = 80
MIN_SPACING = 4
HORIZONTAL_PADDING = 4
DOWNLOAD_TIMEOUT = 30
VALIDATION_TIMEOUT = 10
MAX_NAME_COLUMN_WIDTH = 40
MIN_COLUMN_WIDTH = 8


@dataclass
class DocumentMetadata:
    """Document metadata structure."""
    url: str
    name: Optional[str] = None
    description: Optional[str] = None


# Terminal control utilities for interactive mode
def get_char() -> str:
    """Get single character input without pressing Enter."""
    try:
        # Unix/Linux/macOS
        import termios, tty
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            char = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return char
    except ImportError:
        # Windows fallback - use msvcrt if available
        try:
            import msvcrt
            return msvcrt.getch().decode('utf-8')
        except ImportError:
            # Ultimate fallback - regular input
            user_input = input("Press Enter after your choice: ")
            return user_input[0] if user_input else ''


def clear_screen() -> None:
    """Clear the terminal screen using ANSI escape sequences."""
    print("\033[2J\033[H", end="")


def is_interactive_capable() -> bool:
    """Check if terminal supports interactive features."""
    return sys.stdin.isatty() and sys.stdout.isatty()


def validate_package_name(package_name: str) -> bool:
    """Validate package name for security."""
    if not package_name or len(package_name) > 255:
        return False
    
    # Disallow path traversal attempts
    if '..' in package_name or package_name.startswith('/') or package_name.startswith('\\'):
        return False
    
    # Only allow alphanumeric, hyphens, underscores, and dots
    if not re.match(r'^[a-zA-Z0-9._-]+$', package_name):
        return False
    
    # Disallow reserved names
    reserved_names = {'con', 'prn', 'aux', 'nul', 'com1', 'com2', 'com3', 'com4', 'com5', 'com6', 'com7', 'com8', 'com9', 'lpt1', 'lpt2', 'lpt3', 'lpt4', 'lpt5', 'lpt6', 'lpt7', 'lpt8', 'lpt9'}
    if package_name.lower() in reserved_names:
        return False
    
    return True


def sanitize_filename(filename: str) -> str:
    """Sanitize filename to prevent directory traversal."""
    # Remove path components and just keep the filename
    filename = os.path.basename(filename)
    
    # Replace dangerous characters
    filename = re.sub(r'[<>:"/\\|?*]', '_', filename)
    
    # Limit length
    if len(filename) > 255:
        name, ext = os.path.splitext(filename)
        filename = name[:255-len(ext)] + ext
    
    return filename


def find_config_path() -> Path:
    """Simple two-level config discovery"""
    
    # 1. Check current working directory
    cwd_config = Path.cwd() / "localdocs.config.json"
    if cwd_config.exists():
        return cwd_config
    
    # 2. Fallback to global config
    return Path.home() / ".localdocs" / "localdocs.config.json"


class DocManager:
    """Simple documentation downloader with clean markdown output and metadata tracking."""
    
    def __init__(self, config_path: Optional[str] = None):
        # Use auto-discovery if no path specified
        if config_path is None:
            self.config_path = find_config_path()
        else:
            self.config_path = Path(config_path)
        
        self.base_dir = self.config_path.parent
        
        # Ensure directories exist
        self.base_dir.mkdir(parents=True, exist_ok=True)
        
        # Load or create config
        self.config = self._load_config()
        
        # Set content directory based on config
        storage_dir = self.config.get("storage_directory", ".")
        if storage_dir == ".":
            self.content_dir = self.base_dir
        else:
            self.content_dir = self.base_dir / storage_dir
            self.content_dir.mkdir(exist_ok=True)
        
        # Only create global config when actually using it
        if not self.config_path.exists() and str(self.config_path).startswith(str(Path.home())):
            self._save_config()
    
    def _load_config(self) -> dict:
        """Load config file or create default if it doesn't exist."""
        if self.config_path.exists():
            with open(self.config_path, 'r') as f:
                config = json.load(f)
                
                # Clean up old fields from previous versions
                if "max_keep_versions" in config:
                    del config["max_keep_versions"]
                
                # Migrate documents to include tags field
                self._migrate_tags(config)
                    
                return config
        else:
            return {
                "storage_directory": ".",
                "documents": {}
            }
    
    def _migrate_tags(self, config: dict) -> None:
        """Migrate documents to include tags field for backward compatibility."""
        if "documents" in config:
            for hash_id, metadata in config["documents"].items():
                if "tags" not in metadata:
                    metadata["tags"] = []
    
    def _validate_and_clean_tags(self, tags_input: str) -> List[str]:
        """Validate and clean tag input string. Returns list of valid tags."""
        if not tags_input.strip():
            return []
        
        # Split by comma and clean each tag
        raw_tags = [tag.strip().lower() for tag in tags_input.split(',')]
        valid_tags = []
        
        for tag in raw_tags:
            if not tag:  # Skip empty strings
                continue
            
            # Validate tag format: alphanumeric + hyphens, max 20 chars
            if not tag.replace('-', '').isalnum() or len(tag) > 20:
                print(f"Warning: Skipping invalid tag '{tag}' (use alphanumeric + hyphens, max 20 chars)")
                continue
            
            # Avoid duplicates
            if tag not in valid_tags:
                valid_tags.append(tag)
        
        # Limit to 10 tags max
        if len(valid_tags) > 10:
            print(f"Warning: Only keeping first 10 tags (limit exceeded)")
            valid_tags = valid_tags[:10]
        
        return valid_tags
    
    def _filter_docs_by_tags(self, docs: dict, tag_filters: List[str]) -> dict:
        """Filter documents by tags using AND logic (document must have ALL tags)."""
        if not tag_filters:
            return docs
        
        filtered_docs = {}
        for hash_id, metadata in docs.items():
            doc_tags = metadata.get("tags", [])
            # Check if document has ALL required tags
            if all(tag in doc_tags for tag in tag_filters):
                filtered_docs[hash_id] = metadata
        
        return filtered_docs
    
    def _save_config(self) -> None:
        """Save config to disk."""
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)
    
    def _generate_hash_id(self, url: str) -> str:
        """Generate hash ID from URL for filename."""
        return hashlib.sha256(url.encode('utf-8')).hexdigest()[:8]
    
    def _generate_filename(self, url: str) -> str:
        """Generate hash-based filename."""
        hash_id = self._generate_hash_id(url)
        filename = f"{hash_id}.md"
        return sanitize_filename(filename)
    
    def _download_content(self, url: str) -> Optional[str]:
        """Download content from URL."""
        try:
            # Create request with proper User-Agent
            request = urllib.request.Request(url, headers={
                'User-Agent': 'Mozilla/5.0 (LocalDocs/1.0; Documentation Downloader)'
            })
            with urllib.request.urlopen(request, timeout=DOWNLOAD_TIMEOUT) as response:
                return response.read().decode('utf-8')
        except (urllib.error.URLError, urllib.error.HTTPError) as e:
            print(f"Network error downloading {url}: {e}")
            return None
        except UnicodeDecodeError as e:
            print(f"Encoding error downloading {url}: {e}")
            return None
        except Exception as e:
            print(f"Unexpected error downloading {url}: {e}")
            return None
    
    def validate_url(self, url: str) -> bool:
        """Basic URL validation."""
        try:
            urllib.request.urlopen(urllib.request.Request(url, headers={
                'User-Agent': 'Mozilla/5.0 (LocalDocs/1.0; Documentation Downloader)'
            }), timeout=VALIDATION_TIMEOUT)
            return True
        except (urllib.error.URLError, urllib.error.HTTPError, OSError):
            return False
    
    def add_doc(self, url: str) -> Optional[str]:
        """Download and add a document."""
        print(f"Downloading {url}...")
        
        # Download content
        content = self._download_content(url)
        if content is None:
            print(f"âœ— Failed to download {url}")
            return None
        
        # Generate hash ID and filename
        hash_id = self._generate_hash_id(url)
        filename = self._generate_filename(url)
        file_path = self.content_dir / filename
        
        # Save clean markdown content (no frontmatter)
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        # Update metadata in config (preserve existing metadata)
        if "documents" not in self.config:
            self.config["documents"] = {}
        
        if hash_id not in self.config["documents"]:
            self.config["documents"][hash_id] = {
                "url": url,
                "name": None,
                "description": None,
                "tags": []
            }
        else:
            # Preserve existing metadata, just update URL
            self.config["documents"][hash_id]["url"] = url
        
        self._save_config()
        
        print(f"âœ“ Downloaded as {hash_id}.md")
        return hash_id
    
    def add_multiple(self, urls: List[str]) -> None:
        """Download multiple documents."""
        print(f"Downloading {len(urls)} documents...")
        
        success_count = 0
        for url in urls:
            if self.add_doc(url):
                success_count += 1
        
        print(f"\nCompleted: {success_count}/{len(urls)} documents downloaded")
    
    def add_from_file(self, file_path: str) -> None:
        """Download URLs from a file."""
        try:
            with open(file_path, 'r') as f:
                urls = [line.strip() for line in f if line.strip() and not line.startswith('#')]
            
            if not urls:
                print(f"No URLs found in {file_path}")
                return
            
            self.add_multiple(urls)
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
    
    def add_interactive(self) -> None:
        """Interactive mode for adding URLs."""
        print("Enter URLs (one per line, empty line to finish):")
        urls = []
        
        while True:
            try:
                url = input("> ").strip()
                if not url:
                    break
                urls.append(url)
            except KeyboardInterrupt:
                print("\nCancelled")
                return
        
        if urls:
            self.add_multiple(urls)
        else:
            print("No URLs entered")
    
    def set_metadata(self, hash_id: str, name: Optional[str] = None, description: Optional[str] = None, tags: Optional[str] = None) -> bool:
        """Set name, description, and tags for a document."""
        if "documents" not in self.config:
            self.config["documents"] = {}
        
        if hash_id not in self.config["documents"]:
            print(f"Error: Document '{hash_id}' not found")
            return False
        
        # Update metadata
        if name is not None:
            self.config["documents"][hash_id]["name"] = name
        if description is not None:
            self.config["documents"][hash_id]["description"] = description
        if tags is not None:
            valid_tags = self._validate_and_clean_tags(tags)
            self.config["documents"][hash_id]["tags"] = valid_tags
        
        self._save_config()
        
        updates = []
        if name is not None:
            updates.append(f"name: '{name}'")
        if description is not None:
            updates.append(f"description: '{description}'")
        if tags is not None:
            tag_list = self.config["documents"][hash_id]["tags"]
            if tag_list:
                updates.append(f"tags: [{', '.join(tag_list)}]")
            else:
                updates.append("tags: []")
        
        print(f"Updated {hash_id}: {', '.join(updates)}")
        return True
    
    def list_docs(self, tag_filters: Optional[List[str]] = None) -> bool:
        """List all documents with hash IDs, optionally filtered by tags."""
        if "documents" not in self.config or not self.config["documents"]:
            print("No documents found")
            print("Use 'localdocs add <url>' to add documents")
            return True
        
        docs = self.config["documents"]
        
        # Apply tag filtering if specified
        if tag_filters:
            docs = self._filter_docs_by_tags(docs, tag_filters)
            if not docs:
                print(f"No documents found with tags: {', '.join(tag_filters)}")
                return True
        
        # Print header
        print(f"{'ID':<10} {'Name':<20} {'Tags':<20} {'Description'}")
        print("-" * 80)
        
        # Print documents
        for hash_id, metadata in docs.items():
            name = metadata.get("name") or "[unnamed]"
            description = metadata.get("description") or "[no description]"
            tags = metadata.get("tags", [])
            
            # Format tags for display
            tags_str = ",".join(tags) if tags else ""
            
            # Truncate long fields for display
            if len(name) > 18:
                name = name[:15] + "..."
            if len(tags_str) > 18:
                tags_str = tags_str[:15] + "..."
            if len(description) > 30:
                description = description[:27] + "..."
            
            print(f"{hash_id:<10} {name:<20} {tags_str:<20} {description}")
        
        # Print summary
        total_docs = len(self.config["documents"])
        if tag_filters:
            print(f"\nShowing: {len(docs)} documents with tags [{', '.join(tag_filters)}] (Total: {total_docs})")
        else:
            print(f"\nTotal: {len(docs)} documents")
        return True
    
    def update_doc(self, hash_id: str) -> bool:
        """Re-download a specific document."""
        if "documents" not in self.config or hash_id not in self.config["documents"]:
            print(f"Error: Document '{hash_id}' not found")
            return False
        
        url = self.config["documents"][hash_id]["url"]
        print(f"Updating {hash_id}...")
        
        # Re-download (this will overwrite the existing file)
        result = self.add_doc(url)
        
        if result:
            print(f"âœ“ {hash_id} updated")
            return True
        else:
            print(f"âœ— {hash_id} update failed")
            return False
    
    def update_all(self) -> int:
        """Update all documents."""
        if "documents" not in self.config or not self.config["documents"]:
            print("No documents to update")
            return 0
        
        docs = self.config["documents"]
        print(f"Updating {len(docs)} documents...")
        
        updated_count = 0
        for hash_id in docs.keys():
            if self.update_doc(hash_id):
                updated_count += 1
        
        print(f"\nCompleted: {updated_count}/{len(docs)} documents updated")
        return updated_count
    
    def remove_doc(self, hash_id: str) -> bool:
        """Remove a document."""
        if "documents" not in self.config or hash_id not in self.config["documents"]:
            print(f"Error: Document '{hash_id}' not found")
            return False
        
        # Remove file
        filename = f"{hash_id}.md"
        file_path = self.content_dir / filename
        if file_path.exists():
            file_path.unlink()
        
        # Remove from config
        name = self.config["documents"][hash_id].get("name") or hash_id
        del self.config["documents"][hash_id]
        self._save_config()
        
        print(f"Removed '{name}' ({hash_id})")
        return True
    
    def export_selected_package(self, package_name: str, include_docs: List[str], format_type: str = 'toc', soft_links: bool = False) -> bool:
        """Export selected documents as a package."""
        if "documents" not in self.config or not self.config["documents"]:
            print("No documents available for export")
            return True
        
        # Validate package name for security
        if not validate_package_name(package_name):
            print(f"Error: Invalid package name '{package_name}'. Use only alphanumeric characters, hyphens, underscores, and dots.")
            return False
        
        # Filter documents to only include specified IDs
        all_docs = self.config["documents"]
        docs = {}
        missing_docs = []
        
        for doc_id in include_docs:
            if doc_id in all_docs:
                docs[doc_id] = all_docs[doc_id]
            else:
                missing_docs.append(doc_id)
        
        if missing_docs:
            print(f"Warning: Documents not found: {', '.join(missing_docs)}")
        
        if not docs:
            print("No valid documents to export")
            return False
        
        # Create package directory
        package_path = Path(package_name)
        if package_path.exists():
            print(f"Error: Directory '{package_name}' already exists")
            return False
        
        try:
            package_path.mkdir(parents=True)
        except Exception as e:
            print(f"Error creating directory '{package_name}': {e}")
            return False
        
        # Determine main file name based on format
        if format_type == 'toc':
            main_file = 'index.md'
        elif format_type == 'claude':
            main_file = 'claude-refs.md'
        elif format_type == 'json':
            main_file = 'data.json'
        else:
            print(f"Unknown format: {format_type}")
            return False
        
        # Generate main file content
        if format_type == 'json':
            # JSON is always self-contained
            content = self._generate_json_format(docs, include_content=True)
        else:
            # TOC and Claude formats
            if soft_links:
                content = self._generate_format_with_absolute_paths(docs, format_type)
            else:
                content = self._generate_format_with_relative_paths(docs, format_type)
                # Copy files when not using soft links
                self._copy_files_to_package(docs, package_path)
                # Create config file with only the exported documents
                self._create_filtered_config(docs, package_path)
        
        # Write main file
        main_file_path = package_path / main_file
        try:
            with open(main_file_path, 'w') as f:
                f.write(content)
            
            if soft_links and format_type != 'json':
                print(f"Package '{package_name}' created with {main_file} (soft-links mode)")
            else:
                print(f"Package '{package_name}' created with {main_file}")
            return True
            
        except Exception as e:
            print(f"Error writing to {main_file_path}: {e}")
            return False
    
    def export_package(self, package_name: str, format_type: str = 'toc', soft_links: bool = False) -> bool:
        """Export all documents as a package."""
        if "documents" not in self.config or not self.config["documents"]:
            print("No documents available for export")
            return True
        
        # Export all documents by passing all document IDs
        all_doc_ids = list(self.config["documents"].keys())
        return self.export_selected_package(package_name, all_doc_ids, format_type, soft_links)
    
    def _generate_format_with_relative_paths(self, docs: dict, format_type: str) -> str:
        """Generate format with relative paths for package export."""
        if format_type == 'toc':
            lines = ["# Documentation Index", ""]
            for hash_id, metadata in docs.items():
                name = metadata.get("name") or f"Document {hash_id}"
                description = metadata.get("description") or "No description"
                filename = f"{hash_id}.md"
                line = f"- [{name}]({filename}) - {description}"
                lines.append(line)
            return "\n".join(lines)
        
        elif format_type == 'claude':
            lines = ["# Documentation References", ""]
            for hash_id, metadata in docs.items():
                name = metadata.get("name") or hash_id
                description = metadata.get("description") or f"{name} documentation"
                filename = f"{hash_id}.md"
                ref_line = f"See @{filename} for {description}."
                lines.append(ref_line)
            return "\n".join(lines)
    
    def _generate_format_with_absolute_paths(self, docs: dict, format_type: str) -> str:
        """Generate format with absolute paths for soft-links mode."""
        if format_type == 'toc':
            lines = ["# Documentation Index", ""]
            for hash_id, metadata in docs.items():
                name = metadata.get("name") or f"Document {hash_id}"
                description = metadata.get("description") or "No description"
                file_path = self.content_dir / f"{hash_id}.md"
                abs_path = str(file_path.absolute())
                line = f"- [{name}]({abs_path}) - {description}"
                lines.append(line)
            return "\n".join(lines)
        
        elif format_type == 'claude':
            lines = ["# Documentation References", ""]
            for hash_id, metadata in docs.items():
                file_path = self.content_dir / f"{hash_id}.md"
                name = metadata.get("name") or hash_id
                description = metadata.get("description") or f"{name} documentation"
                abs_path = str(file_path.absolute())
                ref_line = f"See @{abs_path} for {description}."
                lines.append(ref_line)
            return "\n".join(lines)
    
    def _generate_json_format(self, docs: dict, include_content: bool = False) -> str:
        """Generate JSON format export with optional content embedding."""
        import json
        
        export_data = {
            "documents": []
        }
        
        for hash_id, metadata in docs.items():
            doc_data = {
                "id": hash_id,
                "name": metadata.get("name"),
                "description": metadata.get("description"),
                "url": metadata.get("url"),
                "tags": metadata.get("tags", []),
                "file": f"{hash_id}.md"
            }
            
            if include_content:
                # Read and embed the actual content
                file_path = self.content_dir / f"{hash_id}.md"
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        doc_data["content"] = f.read()
                except Exception as e:
                    doc_data["content"] = f"Error reading file: {e}"
            
            export_data["documents"].append(doc_data)
        
        return json.dumps(export_data, indent=2)
    
    def _copy_files_to_package(self, docs: dict, package_path: Path):
        """Copy markdown files to package directory."""
        import shutil
        
        for hash_id in docs.keys():
            source_file = self.content_dir / f"{hash_id}.md"
            dest_file = package_path / f"{hash_id}.md"
            
            if source_file.exists():
                try:
                    shutil.copy2(source_file, dest_file)
                except Exception as e:
                    print(f"Warning: Could not copy {hash_id}.md: {e}")
    
    def _create_filtered_config(self, docs: dict, package_path: Path) -> None:
        """Create config file with only the exported documents."""
        filtered_config = {
            "storage_directory": ".",
            "documents": docs
        }
        
        dest_config = package_path / "localdocs.config.json"
        try:
            with open(dest_config, 'w') as f:
                json.dump(filtered_config, f, indent=2)
        except Exception as e:
            print(f"Warning: Could not create config file: {e}")
    
    def _copy_config_to_package(self, package_path: Path):
        """Copy config file to make package a functional localdocs project."""
        import shutil
        
        dest_config = package_path / "localdocs.config.json"
        try:
            shutil.copy2(self.config_path, dest_config)
        except Exception as e:
            print(f"Warning: Could not copy config file: {e}")


class InteractiveManager:
    """Interactive terminal interface for managing documents."""
    
    def __init__(self, doc_manager: DocManager) -> None:
        self.manager = doc_manager
        self.selected = set()  # Set of selected document hash_ids
        self.current_index = 0  # Current cursor position
        self.docs_list = []  # Ordered list of (hash_id, metadata) tuples
        self.last_terminal_size = None  # Track terminal size changes
        self.current_tag_filters = set()  # Set of active tag filters
        self.available_tags = set()  # All tags available in the collection
        self.in_filter_mode = False  # Whether we're in tag filter mode
    
    def _collect_available_tags(self) -> None:
        """Collect all unique tags from the document collection."""
        self.available_tags = set()
        if "documents" in self.manager.config:
            for metadata in self.manager.config["documents"].values():
                tags = metadata.get("tags", [])
                self.available_tags.update(tags)
    
    def _get_filtered_docs(self) -> dict:
        """Get documents filtered by current tag filters."""
        all_docs = self.manager.config.get("documents", {})
        if not self.current_tag_filters:
            return all_docs
        return self.manager._filter_docs_by_tags(all_docs, list(self.current_tag_filters))
    
    def _update_docs_list(self) -> None:
        """Update the docs list with current filtering and clean up invalid selections."""
        filtered_docs = self._get_filtered_docs()
        self.docs_list = list(filtered_docs.items())
        
        # Clean up selections - remove documents that are no longer visible
        visible_doc_ids = set(filtered_docs.keys())
        self.selected = self.selected.intersection(visible_doc_ids)
        
        # Adjust current index if needed
        if self.docs_list:
            self.current_index = min(self.current_index, len(self.docs_list) - 1)
        else:
            self.current_index = 0
        
    def run(self) -> bool:
        """Main interactive loop."""
        if not is_interactive_capable():
            print("Interactive mode requires a terminal that supports keyboard input.")
            print("Use regular CLI commands instead:")
            print("  localdocs list    - Show all documents")
            print("  localdocs export  - Export documents")
            print("  localdocs remove  - Remove a document")
            return False
            
        # Load documents
        if "documents" not in self.manager.config or not self.manager.config["documents"]:
            print("No documents found. Use 'localdocs add <url>' to add documents first.")
            return True
        
        # Initialize tag filtering system
        self._collect_available_tags()
        self.current_tag_filters = set()
        self.current_index = 0
        self.selected = set()
        self._update_docs_list()
        
        try:
            # Initial render
            self._render_interface()
            
            while True:
                key = get_char()
                
                if not self._handle_key(key):
                    break  # User chose to quit
                    
                # Re-render after key action (checks for resize automatically)
                self._render_interface()
                    
        except KeyboardInterrupt:
            clear_screen()
            print("Interactive mode cancelled.")
            
        return True
    
    def _check_terminal_resize(self) -> bool:
        """Check if terminal has been resized and force re-render if needed."""
        try:
            import shutil
            current_size = shutil.get_terminal_size()
            if self.last_terminal_size != current_size:
                self.last_terminal_size = current_size
                return True  # Size changed
            return False  # No change
        except:
            return False
    
    def _get_terminal_width(self) -> int:
        """Get current terminal width with fallback."""
        try:
            import shutil
            width, _ = shutil.get_terminal_size()
            return width
        except:
            return DEFAULT_TERMINAL_WIDTH
    
    def _render_tree_layout(self, width: int) -> None:
        """Render documents in tree layout for narrow terminals."""
        for i, (hash_id, metadata) in enumerate(self.docs_list):
            # Current document indicator
            cursor = ">" if i == self.current_index else " "
            
            # Selection checkbox
            checkbox = "[x]" if hash_id in self.selected else "[ ]"
            
            # Document info
            name = metadata.get("name") or "[unnamed]"
            description = metadata.get("description") or "[no description]"
            tags = metadata.get("tags", [])
            
            # Main line: cursor + checkbox + hash_id
            print(f"{cursor} {checkbox} {hash_id}")
            
            # Tree branches: name, tags, and description with indentation
            print(f"     â”œâ”€ {name}")
            if tags:
                tags_str = ",".join(tags)
                print(f"     â”œâ”€ tags: {tags_str}")
            
            # Handle long descriptions by wrapping
            desc_width = width - 8  # Account for indentation "     â””â”€ "
            if len(description) <= desc_width:
                print(f"     â””â”€ {description}")
            else:
                # Wrap long descriptions
                words = description.split()
                current_line = ""
                first_line = True
                
                for word in words:
                    if len(current_line + " " + word) <= desc_width:
                        current_line += (" " + word) if current_line else word
                    else:
                        if current_line:
                            if first_line:
                                print(f"     â””â”€ {current_line}")
                                first_line = False
                            else:
                                print(f"        {current_line}")  # Plain continuation, no tree chars
                            current_line = word
                
                # Print final line (plain continuation if not first line)
                if current_line:
                    if first_line:
                        print(f"     â””â”€ {current_line}")
                    else:
                        print(f"        {current_line}")  # Plain continuation
            
            # Add spacing between documents in tree mode
            if i < len(self.docs_list) - 1:
                print()
    
    def _render_column_layout(self, width: int) -> None:
        """Render documents in column layout for wide terminals."""
        # Calculate column widths based on actual content
        # Fixed parts: cursor (1) + space (1) + checkbox (3) + spaces between columns (3)
        fixed_width = 8
        id_width = 10  # Just wide enough for hash IDs + some padding
        remaining_width = width - fixed_width - id_width
        
        if remaining_width > 20:  # Ensure minimum space
            # Calculate the longest name to optimize column sizing
            max_name_length = 0
            for _, metadata in self.docs_list:
                name = metadata.get("name") or "[unnamed]"
                max_name_length = max(max_name_length, len(name))
            
            # Size name column to fit longest name + small buffer, but with reasonable limits
            name_width = min(max_name_length + 2, remaining_width // 2, MAX_NAME_COLUMN_WIDTH)
            name_width = max(name_width, MIN_COLUMN_WIDTH + 2)
            desc_width = max(MIN_COLUMN_WIDTH + 2, remaining_width - name_width)
        else:
            # Very narrow terminal - minimal widths
            name_width = MIN_COLUMN_WIDTH
            desc_width = max(MIN_COLUMN_WIDTH, remaining_width - name_width)
        
        # Display documents in columns
        for i, (hash_id, metadata) in enumerate(self.docs_list):
            # Current document indicator
            cursor = ">" if i == self.current_index else " "
            
            # Selection checkbox
            checkbox = "[x]" if hash_id in self.selected else "[ ]"
            
            # Document info
            name = metadata.get("name") or "[unnamed]"
            description = metadata.get("description") or "[no description]"
            
            # Truncate to fit calculated widths
            if len(name) > name_width:
                name = name[:name_width-3] + "..."
            if len(description) > desc_width:
                description = description[:desc_width-3] + "..."
                
            print(f"{cursor} {checkbox} {hash_id:<{id_width}} {name:<{name_width}} {description}")
    
    def _build_centered_line(self, items: List[str], available_width: int) -> str:
        """Build a line of controls using centered cells."""
        if not items:
            return ""
        
        num_cols = len(items)
        col_width = available_width // num_cols
        
        # Build centered columns using list comprehension
        cells = []
        for item in items:
            padding = (col_width - len(item)) // 2
            cell = f"{' ' * padding}{item}{' ' * (col_width - padding - len(item))}"
            cells.append(cell)
        
        return ''.join(cells)
    
    def _render_controls(self, width: int) -> None:
        """Render control instructions at bottom of interface."""
        # Try extended labels first, then shorthand if needed
        extended_controls = ["[j/k] Navigate", "[Space] Toggle selection", "[a] Select/deselect all", "[f] Filters", "[d] Delete", "[x] Export", "[u] Update selected", "[s] Set metadata", "[q] Quit"]
        shorthand_controls = ["[j/k] Nav", "[Space] Select", "[a] All", "[f] Filters", "[d] Delete", "[x] Export", "[u] Update", "[s] Set", "[q] Quit"]
        
        min_spacing = MIN_SPACING  # Comfortable spacing between controls
        horizontal_padding = HORIZONTAL_PADDING  # 2 spaces on each side for breathing room
        
        # Try extended labels first
        total_content = sum(len(control) for control in extended_controls)
        required_width = total_content + (len(extended_controls) - 1) * min_spacing + horizontal_padding
        
        if required_width <= width:
            # Extended labels fit - use them with natural spacing
            controls = extended_controls
        else:
            # Try shorthand labels
            total_content = sum(len(control) for control in shorthand_controls)
            required_width = total_content + (len(shorthand_controls) - 1) * min_spacing + horizontal_padding
            
            if required_width <= width:
                # Shorthand labels fit - use them with natural spacing
                controls = shorthand_controls
            else:
                # Neither fit naturally - use shorthand with columns
                controls = shorthand_controls
                # Fall through to column layout
        
        # Now render with the chosen labels
        if required_width <= width:
            # Controls fit on one line - use natural even spacing with padding
            available_space = width - sum(len(c) for c in controls) - horizontal_padding
            spaces_between = available_space // (len(controls) - 1) if len(controls) > 1 else 0
            spaces_between = max(spaces_between, min_spacing)
            
            line = "  "  # Left padding
            for i, control in enumerate(controls):
                line += control
                if i < len(controls) - 1:  # Not the last control
                    line += " " * spaces_between
            line += "  "  # Right padding
            print(line)
        else:
            # Use simple 2-column centered layout with shorthand labels
            line1 = controls[:4]  # First 4 controls
            line2 = controls[4:]  # Last 4 controls
            print(self._build_centered_line(line1, width))
            print(self._build_centered_line(line2, width))
    
    def _render_interface(self) -> None:
        """Render the main interface."""
        clear_screen()
        
        print("LocalDocs - Document Manager")
        print("=" * 50)
        print()
        
        # Get terminal width for layout decision
        width = self._get_terminal_width()
        
        # Display documents with layout based on terminal width
        if width < MIN_TERMINAL_WIDTH:
            self._render_tree_layout(width)
        else:
            self._render_column_layout(width)
        
        # Status and controls
        print()
        
        # Create status line with tag filter information
        total_docs = len(self.manager.config.get("documents", {}))
        if self.current_tag_filters:
            # Show filtered status
            tag_list = sorted(list(self.current_tag_filters))
            if len(tag_list) <= 3:
                tags_str = ", ".join(tag_list)
            else:
                tags_str = f"{', '.join(tag_list[:3])}, +{len(tag_list)-3} more"
            print(f"Selected: {len(self.selected)}/{len(self.docs_list)} documents tagged {tags_str}")
        else:
            print(f"Selected: {len(self.selected)}/{len(self.docs_list)} documents")
        print()
        
        self._render_controls(width)
    
    def _handle_key(self, key: str) -> bool:
        """Handle keyboard input. Returns False to quit."""
        if key in ('q', 'Q'):  # q, Q - show quit confirmation
            return self._handle_quit_confirmation()  # True = stay, False = quit
            
        elif key in ('j',):  # j - down
            if self.docs_list and self.current_index < len(self.docs_list) - 1:
                self.current_index += 1
            
        elif key in ('k',):  # k - up
            if self.docs_list and self.current_index > 0:
                self.current_index -= 1
            
        elif key == '\x1b':  # Escape - arrow key sequence
            # Read the full arrow key sequence
            try:
                next_char = get_char()
                if next_char == '[':
                    arrow_key = get_char()
                    if arrow_key == 'A' and self.docs_list and self.current_index > 0:  # Up arrow
                        self.current_index -= 1
                    elif arrow_key == 'B' and self.docs_list and self.current_index < len(self.docs_list) - 1:  # Down arrow
                        self.current_index += 1
                    # Ignore other arrow keys (left/right C/D)
                # If it's not a [ sequence, just ignore
            except:
                # Error reading sequence - ignore
                pass
            
        elif key == ' ':  # Space - toggle current selection
            if self.docs_list:
                current_hash_id = self.docs_list[self.current_index][0]
                if current_hash_id in self.selected:
                    self.selected.remove(current_hash_id)
                else:
                    self.selected.add(current_hash_id)
                    
        elif key in ('a', 'A'):  # Smart select/deselect all
            all_hash_ids = {hash_id for hash_id, _ in self.docs_list}
            if len(self.selected) == len(all_hash_ids):
                # All selected - deselect all
                self.selected.clear()
            else:
                # Some or none selected - select all
                self.selected = all_hash_ids.copy()
                
        elif key in ('d', 'D'):  # Delete selected
            self._handle_delete()
            
        elif key in ('x', 'X'):  # Export selected
            self._handle_export()
            
        elif key in ('u', 'U'):  # Update selected
            self._handle_update()
            
        elif key in ('s', 'S'):  # Set metadata for current
            self._handle_set_metadata()
        
        elif key in ('f', 'F'):  # Filter by tags
            self._handle_tag_filter_mode()
        
        return True
    
    def _handle_delete(self) -> None:
        """Handle delete operation with confirmation."""
        if not self.selected:
            self._show_message("No documents selected for deletion.")
            return
            
        clear_screen()
        print("Delete the following documents?")
        print()
        
        # Show what will be deleted
        for hash_id in self.selected:
            metadata = self.manager.config["documents"][hash_id]
            name = metadata.get("name") or "[unnamed]"
            print(f"- {hash_id} ({name})")
        
        print()
        print("This cannot be undone.")
        response = input("Continue? [y/N]: ").strip().lower()
        
        if response in ('y', 'yes'):
            # Perform deletions
            deleted_count = 0
            for hash_id in list(self.selected):  # Copy to avoid modification during iteration
                if self.manager.remove_doc(hash_id):
                    deleted_count += 1
            
            # Refresh docs list and clear selection
            self.docs_list = list(self.manager.config["documents"].items())
            self.selected.clear()
            if self.docs_list:
                self.current_index = min(self.current_index, len(self.docs_list) - 1)
            else:
                self.current_index = 0
            
            self._show_message(f"Deleted {deleted_count} documents.")
        else:
            self._show_message("Deletion cancelled.")
    
    def _handle_export(self) -> None:
        """Handle export operation with confirmation."""
        if not self.selected:
            self._show_message("No documents selected for export.")
            return
            
        clear_screen()
        print("Export the following documents?")
        print()
        
        # Show what will be exported
        for hash_id in self.selected:
            metadata = self.manager.config["documents"][hash_id]
            name = metadata.get("name") or "[unnamed]"
            print(f"- {hash_id} ({name})")
        
        print()
        package_name = input("Package name: ").strip()
        if not package_name:
            self._show_message("Export cancelled - no package name provided.")
            return
        
        if not validate_package_name(package_name):
            self._show_message("Export cancelled - invalid package name. Use only alphanumeric characters, hyphens, underscores, and dots.")
            return
            
        format_choice = input("Format [toc/claude/json] (default: toc): ").strip().lower()
        if format_choice not in ('toc', 'claude', 'json'):
            format_choice = 'toc'
            
        response = input(f"Create package '{package_name}'? [Y/n]: ").strip().lower()
        
        if response in ('', 'y', 'yes'):
            # Use the new selective export method
            selected_doc_ids = list(self.selected)
            success = self.manager.export_selected_package(package_name, selected_doc_ids, format_choice, False)
            if success:
                self._show_message(f"Package '{package_name}' created successfully.")
            else:
                self._show_message("Export failed.")
        else:
            self._show_message("Export cancelled.")
    
    def _handle_update(self) -> None:
        """Handle update operation with confirmation."""
        if not self.selected:
            self._show_message("No documents selected for update.")
            return
            
        clear_screen()
        print("Update the following documents from their URLs?")
        print()
        
        # Show what will be updated
        for hash_id in self.selected:
            metadata = self.manager.config["documents"][hash_id]
            name = metadata.get("name") or "[unnamed]"
            print(f"- {hash_id} ({name})")
        
        print()
        print("This will re-download content from the original URLs.")
        response = input("Continue? [Y/n]: ").strip().lower()
        
        if response in ('', 'y', 'yes'):
            updated_count = 0
            for hash_id in self.selected:
                if self.manager.update_doc(hash_id):
                    updated_count += 1
            
            self._show_message(f"Updated {updated_count}/{len(self.selected)} documents.")
        else:
            self._show_message("Update cancelled.")
    
    def _handle_set_metadata(self) -> None:
        """Handle setting metadata for current document."""
        if not self.docs_list:
            return
            
        current_hash_id = self.docs_list[self.current_index][0]
        metadata = self.manager.config["documents"][current_hash_id]
        
        clear_screen()
        print(f"Edit metadata for {current_hash_id}:")
        print()
        
        # Get current values
        current_name = metadata.get("name") or ""
        current_desc = metadata.get("description") or ""
        
        # Prompt for new values
        print(f"Name (current: {current_name or '[unnamed]'}): ", end="")
        new_name = input().strip()
        
        print(f"Description (current: {current_desc or '[no description]'}): ", end="")
        new_description = input().strip()
        
        # Use current values if nothing entered
        if not new_name:
            new_name = current_name
        if not new_description:
            new_description = current_desc
            
        # Update metadata
        self.manager.set_metadata(current_hash_id, 
                                new_name if new_name != current_name else None,
                                new_description if new_description != current_desc else None)
        
        # Refresh docs list and tags (tags might have changed)
        self._collect_available_tags()
        self._update_docs_list()
        
        self._show_message(f"Updated metadata for {current_hash_id}.")
    
    def _handle_tag_filter_mode(self) -> None:
        """Handle tag filter mode interface."""
        if not self.available_tags:
            self._show_message("No tags available in the collection.")
            return
        
        # Convert available tags to a sorted list for consistent ordering
        available_tags_list = sorted(list(self.available_tags))
        current_tag_index = 0
        
        while True:
            clear_screen()
            
            # Calculate filtered doc count
            temp_filtered = self._get_filtered_docs()
            filtered_count = len(temp_filtered)
            total_count = len(self.manager.config.get("documents", {}))
            
            print("Filter by tags:")
            print()
            
            # Display tags with checkboxes
            for i, tag in enumerate(available_tags_list):
                cursor = ">" if i == current_tag_index else " "
                checkbox = "[x]" if tag in self.current_tag_filters else "[ ]"
                print(f"{cursor} {checkbox} {tag}")
            
            print()
            print(f"{filtered_count} documents match current filters (Total: {total_count})")
            print()
            print("[j/k] navigate  [space] toggle  [c] clear all  [enter/esc] back to documents")
            
            key = get_char()
            
            if key in ('j',) and current_tag_index < len(available_tags_list) - 1:
                current_tag_index += 1
            elif key in ('k',) and current_tag_index > 0:
                current_tag_index -= 1
            elif key == '\x1b':  # Escape to exit
                break
            elif key == ' ' and available_tags_list:
                # Toggle current tag
                current_tag = available_tags_list[current_tag_index]
                if current_tag in self.current_tag_filters:
                    self.current_tag_filters.remove(current_tag)
                else:
                    self.current_tag_filters.add(current_tag)
                # Update docs list and clean selections
                self._update_docs_list()
            elif key in ('c', 'C'):
                # Clear all filters
                self.current_tag_filters.clear()
                self._update_docs_list()
            elif key in ('\r', '\n'):  # Enter to exit
                break  # Return to main interface
    
    def _handle_quit_confirmation(self) -> bool:
        """Handle quit confirmation. Returns False to quit, True to stay."""
        clear_screen()
        
        # Show context-aware message
        if self.selected:
            print(f"You have {len(self.selected)} document{'s' if len(self.selected) != 1 else ''} selected.")
        
        print("Exit interactive manager?")
        print()
        print("[y] Yes, exit    [n] No, stay")
        
        while True:
            key = get_char().lower()
            
            if key == 'y':
                return False  # Quit the manager
            elif key == 'n':
                return True  # Stay in manager
            # Ignore all other keys and stay in confirmation
    
    def _show_message(self, message: str) -> None:
        """Show a message and wait for keypress."""
        clear_screen()
        print(message)
        print()
        print("Press any key to continue...")
        get_char()


def main() -> None:
    """Main CLI entry point."""
    try:
        parser = argparse.ArgumentParser(description="LocalDocs - Simple documentation downloader")
        subparsers = parser.add_subparsers(dest='command', help='Available commands')
        
        # Add command
        add_parser = subparsers.add_parser('add', help='Download documents')
        add_parser.add_argument('urls', nargs='*', help='URLs to download')
        add_parser.add_argument('-f', '--from-file', help='Read URLs from file')
        
        # Set command
        set_parser = subparsers.add_parser('set', help='Set document metadata')
        set_parser.add_argument('hash_id', help='Document hash ID')
        set_parser.add_argument('-n', '--name', help='Document name')
        set_parser.add_argument('-d', '--description', help='Document description')
        set_parser.add_argument('-t', '--tags', help='Comma-separated tags (e.g., "frontend,react,tutorial")')
        
        # List command
        list_parser = subparsers.add_parser('list', help='List all documents')
        list_parser.add_argument('--tags', help='Filter by tags (comma-separated, AND logic)')
        
        # Update command
        update_parser = subparsers.add_parser('update', help='Update documents')
        update_parser.add_argument('hash_id', nargs='?', help='Specific document to update')
        
        # Remove command
        remove_parser = subparsers.add_parser('remove', help='Remove document')
        remove_parser.add_argument('hash_id', help='Document hash ID')
        
        # Export command
        export_parser = subparsers.add_parser('export', help='Export documentation packages')
        export_parser.add_argument('package_name', help='Package directory name')
        export_parser.add_argument('--format', choices=['toc', 'claude', 'json'], 
                                  default='toc', help='Export format (default: toc)')
        export_parser.add_argument('--soft-links', action='store_true',
                                  help='Use absolute paths without copying files')
        export_parser.add_argument('--include', 
                                  help='Comma-separated list of document IDs to include (default: all documents)')
        export_parser.add_argument('--tags',
                                  help='Filter by tags (comma-separated, AND logic) - can combine with --include')
        
        # Manage command
        manage_parser = subparsers.add_parser('manage', help='Interactive document manager')
        
        args = parser.parse_args()
    
        if not args.command:
            parser.print_help()
            sys.exit(1)
        
        # Initialize DocManager
        manager = DocManager()
        
        # Route to appropriate method
        if args.command == 'add':
            if args.from_file:
                manager.add_from_file(args.from_file)
            elif args.urls:
                manager.add_multiple(args.urls)
            else:
                manager.add_interactive()
        elif args.command == 'set':
            manager.set_metadata(args.hash_id, args.name, args.description, args.tags)
        elif args.command == 'list':
            tag_filters = None
            if args.tags:
                tag_filters = manager._validate_and_clean_tags(args.tags)
            manager.list_docs(tag_filters)
        elif args.command == 'update':
            if args.hash_id:
                manager.update_doc(args.hash_id)
            else:
                manager.update_all()
        elif args.command == 'remove':
            manager.remove_doc(args.hash_id)
        elif args.command == 'export':
            # Determine which documents to export
            if args.include or args.tags:
                # Start with all documents
                all_docs = manager.config.get("documents", {})
                selected_docs = all_docs.copy()
                
                # Apply tag filtering if specified
                if args.tags:
                    tag_filters = manager._validate_and_clean_tags(args.tags)
                    selected_docs = manager._filter_docs_by_tags(selected_docs, tag_filters)
                
                # Apply ID filtering if specified (further narrows selection)
                if args.include:
                    include_doc_ids = [doc_id.strip() for doc_id in args.include.split(',') if doc_id.strip()]
                    # Keep only docs that are both in tag filter results AND in include list
                    selected_docs = {doc_id: metadata for doc_id, metadata in selected_docs.items() 
                                   if doc_id in include_doc_ids}
                
                # Export selected documents
                include_docs = list(selected_docs.keys())
                if include_docs:
                    manager.export_selected_package(args.package_name, include_docs, args.format, args.soft_links)
                else:
                    print("No documents match the specified criteria")
            else:
                # Export all documents (existing behavior)
                manager.export_package(args.package_name, args.format, args.soft_links)
        elif args.command == 'manage':
            interactive = InteractiveManager(manager)
            interactive.run()
    
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()